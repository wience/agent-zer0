{
  "title": "Overview",
  "content": "# Overview\n\n2022-07-03 18:44\n\n## File Structure\n\nThe Mini Program is divided into two layers: `app` and `page`. The app describes the whole program; the page describes the individual pages.\n\nThe app consists of three files and must be placed in the root directory of the project.\n\n|     |     |     |\n| --- | --- | --- |\n| **File** | **Mandatory** | **Function** |\n| app.js | Yes | Mini Program logic. |\n| app.json | Yes | Mini Program global configuration. |\n| app.acss | No | Mini Program global style sheet. |\n\nThe page consists of four file types:\n\n|     |     |     |\n| --- | --- | --- |\n| **File type** | **Mandatory** | **Function** |\n| js | Yes | Page logic. |\n| axml | Yes | Page structure. |\n| acss | No | Page style sheet. |\n| json | No | Page configuration. |\n\n**Note**: For the convenience of developers, we specify these four files must have the same path and filename. All the codes written by the developer will eventually be packaged into a JavaScript script which runs when Mini Program start and is destroyed when Mini Program finish running.\n\n## Logic Structure\n\nThe core of Mini Program is a responsive data binding system, composed of the view layer and logic layer. The two layers keep always synchronous. Whenever the data is modified in logic layer, the view layer is updated accordingly.\n\nSee the following simple example.\n\ncopy\n\n```html\n<!-- View layer -->\n<view> Hello {{name}}! </view>\n<button onTap=\"changeName\"> Click me! </button>\n```\n\ncopy\n\n```javascript\n// Logic layer\nvar initialData = {\n  name: 'AppContainer'\n};\n// Register a Page.\nPage({\n  data: initialData,\n  changeName(e) {\n    // sent data change to view\n    this.setData({\n      name: 'Mini Program'\n    })\n  }\n});\n```\n\nIn the above codes, the framework automatically binds the `name` in the logic layer to the `name` in the view layer, so whenever the page is opened, it displays `Hello AppContainer!`\n\nWhen the user presses the button, the view layer sends the `changeName` event to the logic layer. The logic layer finds the corresponding event handler. The logic layer executes the `setData` operation, changing the `name` from `AppContainer` to `Mini Program`. Since the logic layer and view layer are already bound, the displaying of the view layer automatically changes to `Hello Mini Program!`.\n\n**Note**: Since the framework does not work in the browser, some web capabilities of JavaScript cannot be used, such as the `document` and `window` objects.\n\nFor the logic layer js, the codes can be organized through the es2015 modular syntax:\n\ncopy\n\n```javascript\nimport util from './util'; // Loading relative path\nimport absolute from '/absolute'; // Loading project root directory path\n```\n\n### Reserved Names for Module\n\nMini Program regards some object names in browser such as `window`, `document` as reserved names for future use. The reserved names include **globalThis**, **global**, **fetch**, **self**, **window**, **document**, **location**, **XMLHttpRequest**. Please do not use these names for module name, or the module can not be used normally. For example:\n\ncopy\n\n```javascript\nimport { window } from './myWindow'\nconsole.log(window) // undefined\n```\n\nThe above codes show that if using the reserved name as the module name, the imported module will be `undefined`. So you should not use these reserved names or rename the module name by using `as` when importing the module. For example:\n\ncopy\n\n```javascript\nimport { window as myWindow } from './myWindow'\nconsole.log(myWindow)\n```\n\n## Third-party NPM Module\n\nThe Mini Program supports introduction of the third-party module. It is required to firstly run the following command to install the module in the Mini Program root directory:\n\ncopy\n\n```shell\n$ npm install lodash --save\n```\n\nAfter the installation, it can be used directly in the logic layer:\n\ncopy\n\n```javascript\nimport lodash from 'lodash'; // Loading the third-party npm module\n```\n\nNote: Since the third-party module in the node\\_modules does not go through the converter, for the compatibility in various terminals, the codes in the node\\_modules should be converted into the es5 format before using. For the module format, it is recommended to use the import/export of es2015. Meanwhile, the browser related capabilities of the browser cannot be used either.",
  "date": "2022-07-03",
  "source": "https://miniprogram.gcash.com/docs/miniprogram_gcash/mpdev/framework_overview",
  "path": "miniprogram_gcash",
  "type": "miniprogram",
  "filename": "miniprogram.gcash.com_docs_miniprogram_gcash_mpdev_framework_overview.json"
}