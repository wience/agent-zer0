{
  "title": "Suggestions on Performance Optimization",
  "content": "# Suggestions on Performance Optimization\n\n2022-07-03 18:44\n\n## Operating Principle\n\nDifferent from the traditional H5 applications, Mini Program operation architecture is divided into two parts -- webview and worker. The webview is for rendering, and the worker is for data storage and service logic execution.\n\n1. Communication between webview and worker is asynchronous. This means the data is not rendered immediately when setData is called, and asynchronous transmission from worker to webview occurs.\n\n2. During the transmission, the data is serialized as a string, and transferred by means of evaluateJavascript. The data size affects the performance.\n\n## Optimizing First Screen\n\nThe first screen may be defined differently. Here it means the first meaningful render of the service. For example: with regard to a list page, the first screen means the contents rendered for the first time in the list.\n\n### Controlling Size of Mini Program Resource Package\n\nWhen the use accesses Mini Program for the first time,  mobile App client downloads Mini Program resource package from CDN, so the size of the resource package affects the Mini Program startup performance.\n\n**Optimization suggestions**\n\n- Delete the useless image resources, because all image resources are packaged by default.\n\n- Control the size of images and avoid using large picture. It is recommended to upload large pictures via CDN channels.\n\n- Clear useless codes in time\n\n### Advance Data Request to onLoad\n\n- Upon operation, Mini Program triggers the onLoad lifecycle function of the page, and then transfers the initial page data from worker to webview for the initial render.\n\n- When the initial page render is completed, a notification is sent from webview to worker and triggers the onReady lifecycle function.\n\nSome Mini Programs send requests in onReady which causes delay of first screen render.\n\n**Optimization suggestion**\n\nAdvance data request to onLoad\n\n### Control the Number of Nodes to Be Rendered at Once in the First Screen\n\nAfter the service request is returned, it generally calls the setData to trigger page re-render. The execution process is as below:\n\n1. Data is sent from worker to webview\n\n2. webview constructs virtual DOM as per the data transferred, makes difference comparison with the previous data (starting from the root node), and starts render.\n\nDue to the data serialization in communication from worker to webview, and then the execution of evaluateJavascript in the webview, the first screen render performance is affected if the data transmitted once is too large.\n\nin addition, if the construction nodes are too many or the nested hierarchy is too deep on webview, say, more than 100 list items to be rendered once in the list page of some Mini Program and each list item containing nested contents, but less than 10 items to be displayed on the whole screen, the different comparison takes long time, a large number of DOMs are constructed once in the first screen, and the first screen render performance is compromised.\n\n**Optimization suggestions**\n\n- setData data quantity should not be too large; do not transfer too long list once.\n\n- Do not construct too many nodes on the first screen. The service end may request a large quantity of data once. Do not run setData all at once. It is possible to setData partial data and wait for a while (say, 400ms, depending on the specific service) and then call $spliceData to transfer the remaining data.\n\n## Optimize setData Logic\n\nAny page change triggers setData. At the same time, multiple setData may trigger the page re-render. The following four interfaces trigger webview page re-render.\n\n- **Page.prototype.setData:** Triggers the difference comparison of the whole page\n\n- **Page.prototype.$spliceData:** Optimizes long list and avoid transferring whole list all at once and triggering the difference comparison of the whole page\n\n- **Component.prototype.setData:** Starts the difference comparison from the corresponding component node\n\n- **Component.prototype.$spliceData:** Optimizes long list and avoid transferring whole list all at once. Only makes difference comparison from the corresponding component node.\n\n**Optimization suggestions**\n\n- Avoid triggering setData or $spliceData frequently, no matter on the page level or component level. In our analyzed cases, some pages contain countdown logic but the countdown is triggered too frequently (in microseconds).\n\n- When it is required to trigger re-render frequently, avoid using page-level setData or $spliceData. This block can be encapsulated into a custom component, and then the component-level setData and $spliceData can be used to trigger component re-render.\n\n- For render of long data list, use $spliceData to append data in several times instead of transfer of the whole list.\n\n- For complicated page, it is recommended to encapsulate it into custom component to minimize the page-level setData.\n\n**Optimization case**\n\nSuggest specifying path to set data:\n\ncopy\n\n```javascript\nthis.setData({\n  'array[0]': 1,\n  'obj.x':2,\n});\n```\n\nNot suggesting the following method (although this.data is copied, the attribute is changed directly):\n\ncopy\n\n```javascript\nconst array = this.data.array.concat();\narray[0] = 1;\nconst obj={...this.data.obj};\nobj.x=2;\nthis.setData({array,obj});\n```\n\nEven not suggesting direct change of this.data (violating the immutable data principle):\n\ncopy\n\n```javas\nthis.data.array[0]=1;\nthis.data.obj.x=2;\nthis.setData(this.data)\n```\n\nUsing $spliceData for long list\n\ncopy\n\n```javascript\nthis.$spliceData({ 'a.b': [1, 0, 5, 6] })\n```\n\n**Note:**\n\nSometimes when service logic are encapsulated in component, it is only required to call setData within the component when the component UI needs re-render. In other occasions, however, it is required to trigger component re-render from the page. For example, the onPageScroll event is monitored on page, and it is required to notify the corresponding component to render again when the event is trigger. Now the measure is as below:\n\ncopy\n\n```javascript\n// /pages/index/index.js\nPage({\n    onPageScroll(e) {\n        if (this.xxcomponent) {\n            this.xxcomponent.setData({\n                scrollTop: e.scrollTop\n            })\n        }\n    }\n})\n// /components/index/index.js\nComponent({\n    didMount(){\n        this.$page.xxcomponent = this;\n    }\n})\n```\n\nIt is possible to mount the component to the corresponding page in the didMount, so that the call of component-level setData in the page triggers re-render of the component only.\n\n## Use Key Parameter\n\nThe “key” can be used in “for” to increase performance. Note that the “key” cannot be set on blocks.\n\nSample codes:\n\ncopy\n\n```html\n<view a:for=\"{{array}}\" key=\"{{item.id}}\"></view>\n<block a:for=\"{{array}}\"><view key=\"{{item.id}}\"></view></block>\n```",
  "date": "2022-07-03",
  "source": "https://miniprogram.gcash.com/docs/miniprogram_gcash/mpdev/framework_suggestions-on-performance-optimization",
  "path": "miniprogram_gcash",
  "type": "miniprogram",
  "filename": "miniprogram.gcash.com_docs_miniprogram_gcash_mpdev_framework_suggestions-on-performance-optimization.json"
}